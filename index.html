<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Guardian Quant ‚Äî Standalone (Paper Trading ¬∑ Multi)</title>
  <style>
    :root{
      --bg:#0b1220; --card:#0f1a2b; --card2:#0c1626; --bd:rgba(255,255,255,.10);
      --txt:#e8f0ff; --mut:rgba(232,240,255,.72);
      --blue:#3b82f6; --blue2:#2563eb; --green:#22c55e; --red:#ef4444; --amber:#f59e0b;
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
      background:radial-gradient(1200px 800px at 20% -10%, rgba(59,130,246,.20), transparent 60%),
                 radial-gradient(900px 650px at 90% 10%, rgba(245,158,11,.10), transparent 50%),
                 var(--bg);
      color:var(--txt)
    }
    .wrap{max-width:1180px; margin:0 auto; padding:18px 16px 60px}
    .topbar{display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 16px;
      border:1px solid var(--bd);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius:16px; position:sticky; top:12px; z-index:10; backdrop-filter: blur(10px)
    }
    .brand{display:flex; gap:12px; align-items:center}
    .logo{width:36px; height:36px; border-radius:12px; background:rgba(59,130,246,.18);
      border:1px solid rgba(59,130,246,.35); display:grid; place-items:center; font-weight:800; color:#9cc1ff
    }
    .title b{display:block; font-size:14px; letter-spacing:.2px}
    .title span{display:block; font-size:12px; color:var(--mut)}
    .pill{display:flex; align-items:center; gap:10px; padding:10px 12px; border:1px solid var(--bd); border-radius:999px; background:rgba(0,0,0,.14)}
    .dot{width:10px;height:10px;border-radius:999px;background:rgba(245,158,11,.95); box-shadow:0 0 0 6px rgba(245,158,11,.10)}
    .dot.on{background:rgba(34,197,94,.95); box-shadow:0 0 0 6px rgba(34,197,94,.10)}
    .dot.off{background:rgba(148,163,184,.80); box-shadow:0 0 0 6px rgba(148,163,184,.10)}
    .small{font-size:12px;color:var(--mut)}

    .grid{display:grid; grid-template-columns: 1fr; gap:14px; margin-top:14px}
    @media (min-width: 980px){ .grid{grid-template-columns: 1.15fr .85fr} }

    .card{border:1px solid var(--bd); background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)); border-radius:18px; padding:14px}
    .card h2{margin:0 0 10px; font-size:14px; letter-spacing:.2px}

    .row{display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end}
    label{display:flex; flex-direction:column; gap:6px; font-size:12px; color:var(--mut); min-width:150px}
    input,select{height:40px; padding:0 12px; border-radius:12px; border:1px solid var(--bd); background:rgba(0,0,0,.16); color:var(--txt); outline:none}
    input:focus,select:focus{border-color:rgba(59,130,246,.65); box-shadow:0 0 0 4px rgba(59,130,246,.12)}

    .btns{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    button{height:40px; padding:0 14px; border:0; border-radius:12px; cursor:pointer; font-weight:700; color:#fff;
      background:linear-gradient(180deg, var(--blue), var(--blue2)); box-shadow:0 10px 30px rgba(37,99,235,.20)}
    button.secondary{background:rgba(255,255,255,.10); box-shadow:none}
    button.danger{background:linear-gradient(180deg, rgba(239,68,68,.95), rgba(185,28,28,.95)); box-shadow:0 10px 30px rgba(239,68,68,.18)}
    button:disabled{opacity:.55; cursor:not-allowed}

    .kpi{display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px}
    @media (min-width: 680px){ .kpi{grid-template-columns: repeat(4, minmax(0,1fr));} }
    .k{padding:12px; border:1px solid var(--bd); background:rgba(0,0,0,.14); border-radius:14px}
    .k .t{font-size:11px; color:var(--mut)}
    .k .v{font-size:20px; font-weight:800; margin-top:4px}

    .banner{display:none; margin-top:12px; padding:12px 14px; border-radius:16px; border:1px solid rgba(239,68,68,.38);
      background:linear-gradient(180deg, rgba(239,68,68,.18), rgba(0,0,0,.10));
    }
    .banner.on{display:block}
    .banner b{display:block; font-size:14px}
    .banner span{display:block; color:rgba(255,255,255,.85); margin-top:2px}

    .list{display:flex; flex-direction:column; gap:10px}
    .item{border:1px solid var(--bd); background:rgba(0,0,0,.14); border-radius:14px; padding:12px}
    .item .head{display:flex; justify-content:space-between; gap:10px; align-items:center}
    .tag{font-size:12px; padding:4px 10px; border-radius:999px; border:1px solid var(--bd); color:var(--mut)}
    .tag.buy{border-color:rgba(34,197,94,.35); color:rgba(34,197,94,.95)}
    .tag.sell{border-color:rgba(239,68,68,.35); color:rgba(255,165,165,.95)}
    .tag.ask{border-color:rgba(245,158,11,.35); color:rgba(245,158,11,.95)}
    .tag.hold{border-color:rgba(148,163,184,.35); color:rgba(203,213,225,.95)}

    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .logs{height:220px; overflow:auto; padding:12px; border-radius:14px; border:1px solid var(--bd); background:rgba(0,0,0,.18); color:rgba(232,240,255,.88)}
    .logs div{padding:4px 0; border-bottom:1px dashed rgba(255,255,255,.06)}

    .rightCol{display:flex; flex-direction:column; gap:14px}
    .hint{font-size:12px; color:var(--mut); line-height:1.35}

    .seg{display:flex; gap:8px; flex-wrap:wrap}
    .segbtn{height:38px; padding:0 12px; border-radius:999px; border:1px solid var(--bd); background:rgba(0,0,0,.12); color:var(--txt); font-weight:800; cursor:pointer; box-shadow:none}
    .segbtn:hover{border-color:rgba(59,130,246,.55)}
    .segbtn.active{background:linear-gradient(180deg, rgba(59,130,246,.95), rgba(37,99,235,.95)); border-color:rgba(59,130,246,.75); box-shadow:0 12px 28px rgba(37,99,235,.20)}

    .table{
      width:100%; border-collapse:separate; border-spacing:0 8px;
      font-size:12px; color:rgba(232,240,255,.88)
    }
    .table th{color:var(--mut); font-weight:700; text-align:left; padding:0 10px}
    .table td{
      background:rgba(0,0,0,.14); border:1px solid var(--bd);
      padding:10px; border-left:none; border-right:none;
    }
    .table tr td:first-child{border-left:1px solid var(--bd); border-top-left-radius:12px; border-bottom-left-radius:12px}
    .table tr td:last-child{border-right:1px solid var(--bd); border-top-right-radius:12px; border-bottom-right-radius:12px}
    .muted{color:var(--mut)}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo">G</div>
        <div class="title">
          <b>Guardian Quant ‚Äî Standalone (Multi)</b>
          <span>Paper trading ¬∑ 100% no browser ¬∑ Binance klines</span>
        </div>
      </div>
      <div class="pill">
        <span id="dot" class="dot off"></span>
        <span class="small" id="runLabel">Loop: OFF</span>
        <span class="small">¬∑</span>
        <span class="small" id="profileLabel">Perfil (rodando): -</span>
        <span class="small">¬∑</span>
        <span class="small" id="tickLabel">√öltimo tick: ‚Äî</span>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h2>Controles</h2>
        <div class="btns">
          <button id="btnStart">Ligar Rob√¥</button>
          <button id="btnStop" class="secondary" disabled>Parar</button>
          <button id="btnOnce" class="secondary">Rodar 1x</button>
          <button id="btnReset" class="secondary">Reset geral</button>
          <button id="btnUnlock" class="danger">Desbloquear trava (2 Loss)</button>
          <button id="btnTestMode" class="secondary">Modo Teste: OFF</button>
        </div>
        <div class="banner" id="lockBanner">
          <b>üîí SISTEMA TRAVADO</b>
          <span id="lockReason">Bloqueado por regra de seguran√ßa.</span>
        </div>

        <div style="margin-top:12px" class="row">
          <label>Universo
            <select id="cfgUniverse">
              <option value="SINGLE" selected>1 cripto</option>
              <option value="MULTI">V√°rias criptos</option>
              <option value="ALL_USDT">Todas (USDT Spot)</option>
            </select>
          </label>

          <label>Tickers (sele√ß√£o)
            <select id="cfgSymbols" multiple size="7" style="height:auto; padding:10px 12px;">
              <option value="BTCUSDT" selected>BTCUSDT</option>
              <option value="ETHUSDT">ETHUSDT</option>
              <option value="BNBUSDT">BNBUSDT</option>
              <option value="SOLUSDT">SOLUSDT</option>
              <option value="XRPUSDT">XRPUSDT</option>
              <option value="ADAUSDT">ADAUSDT</option>
              <option value="DOGEUSDT">DOGEUSDT</option>
            </select>
          </label>

          <label>M√°x s√≠mbolos (ALL)
            <input id="cfgMaxSymbolsAll" type="number" value="40" min="5" max="500" />
          </label>

          <label>Delay por s√≠mbolo (ms)
            <input id="cfgPerSymbolDelayMs" type="number" value="35" min="0" max="500" />
          </label>
        </div>

        <div style="margin-top:10px" class="row">
          <label>Intervalo (klines)
            <select id="cfgInterval">
              <option value="1m">1m</option>
              <option value="3m">3m</option>
              <option value="5m">5m</option>
              <option value="15m">15m</option>
              <option value="30m" selected>30m</option>
              <option value="1h">1h</option>
              <option value="2h">2h</option>
              <option value="4h">4h</option>
              <option value="6h">6h</option>
              <option value="12h">12h</option>
              <option value="1d">1d</option>
            </select>
          </label>

          <label>Loop (seg)
            <input id="cfgLoopSec" type="number" value="10" min="2" max="3600" />
          </label>

          <label>Klines limit
            <input id="cfgLimit" type="number" value="300" min="60" max="1000" />
          </label>
        </div>

        <div style="margin-top:10px" class="row">
          <div style="min-width:340px">
            <div class="small" style="margin-bottom:6px">Perfis</div>
            <div class="seg" id="profileSeg">
              <button type="button" class="segbtn" data-prof="CONSERVADOR">Conservador</button>
              <button type="button" class="segbtn" data-prof="BALANCEADO">Balanceado</button>
              <button type="button" class="segbtn" data-prof="AGRESSIVO">Agressivo</button>
            </div>
            <div class="small" id="profileHint" style="margin-top:6px">Ativo: Balanceado</div>
          </div>
          <div class="hint" style="flex:1; min-width:260px">
            Regra (Op√ß√£o 2): <b>MA200 define o lado</b>. Se EMA estiver contra, o bot entra com <b>0.5x risco</b>.
          </div>
        </div>

        <div style="margin-top:10px" class="row">
          <label>Modo
            <select id="cfgMode">
              <option value="ASK">ASK (mostra op√ß√µes)</option>
              <option value="AUTO" selected>AUTO (executa)</option>
            </select>
          </label>

          <label>Trava trades repetidos
            <select id="cfgNoRepeat">
              <option value="ON" selected>ON</option>
              <option value="OFF">OFF</option>
            </select>
          </label>

          <label>Risco % por trade (1‚Äì2%)
            <input id="cfgRiskPct" type="number" value="1.3" min="1" max="2" step="0.1" />
          </label>

          <label>M√°x trades abertos
            <input id="cfgMaxOpen" type="number" value="5" min="1" max="20" />
          </label>

          <label>M√°x daily DD %
            <input id="cfgMaxDailyDD" type="number" value="3.0" min="0.5" max="20" step="0.1" />
          </label>
        </div>

        <div style="margin-top:10px" class="row">
          <label>ATR period
            <input id="cfgAtrPeriod" type="number" value="14" min="7" max="50" />
          </label>
          <label>ATR Stop (x)
            <input id="cfgAtrStop" type="number" value="2.2" min="0.5" max="6" step="0.1" />
          </label>
          <label>ATR Target (x)
            <input id="cfgAtrTarget" type="number" value="3.2" min="0.8" max="10" step="0.1" />
          </label>
          <label>Trailing ATR (x)
            <input id="cfgAtrTrail" type="number" value="2.2" min="0" max="10" step="0.1" />
          </label>
          <label>Break-even (R ‚â•)
            <input id="cfgBreakEvenR" type="number" value="1.3" min="0" max="6" step="0.1" />
          </label>
        </div>

        <div style="margin-top:12px" class="row">
          <label>Time-stop
            <select id="cfgTimeStopOn">
              <option value="ON" selected>ON</option>
              <option value="OFF">OFF</option>
            </select>
          </label>
          <label>Time-stop (candles)
            <input id="cfgTimeStopCandles" type="number" value="6" min="1" max="50" />
          </label>

          <label>Parcial
            <select id="cfgPartialOn">
              <option value="ON" selected>ON</option>
              <option value="OFF">OFF</option>
            </select>
          </label>
          <label>Parcial em (R ‚â•)
            <input id="cfgPartialAtR" type="number" value="1.0" min="0.1" max="10" step="0.1" />
          </label>
          <label>Parcial (% fecha)
            <input id="cfgPartialPct" type="number" value="50" min="1" max="99" step="1" />
          </label>

          <label>BE ap√≥s parcial
            <select id="cfgBEAfterPartialOn">
              <option value="ON" selected>ON</option>
              <option value="OFF">OFF</option>
            </select>
          </label>
        </div>

        <div style="margin-top:10px" class="hint">
          <b>Execu√ß√£o:</b><br/>
          ‚Ä¢ <b>AUTO:</b> abre automaticamente <b>score ‚â• 7</b> (se houver BUY/SELL).<br/>
          ‚Ä¢ <b>ASK:</b> cria op√ß√£o em <b>[7,9)</b> e executa autom√°tico em <b>score ‚â• 9</b>.<br/>
          ‚Ä¢ <b>&lt;7:</b> ignora.<br/><br/>
          <b>Multi:</b> em ALL_USDT, use ‚ÄúM√°x s√≠mbolos‚Äù e ‚ÄúDelay por s√≠mbolo‚Äù para evitar rate-limit.
        </div>
      </div>

      <div class="rightCol">
        <div class="card">
          <h2>Carteira (Paper)</h2>
          <div class="kpi">
            <div class="k"><div class="t">Saldo (USD)</div><div class="v" id="kCash">$100.00</div></div>
            <div class="k"><div class="t">Equity (USD)</div><div class="v" id="kEquity">$100.00</div></div>
            <div class="k"><div class="t">P/L total</div><div class="v" id="kPL">$0.00</div></div>
            <div class="k"><div class="t">Daily DD</div><div class="v" id="kDD">0.00%</div></div>
          </div>
          <div class="kpi" style="margin-top:10px">
            <div class="k"><div class="t">Wins / Losses</div><div class="v" id="kWL">0 / 0</div></div>
            <div class="k"><div class="t">Loss consecutivos</div><div class="v" id="kStreak">0</div></div>
            <div class="k"><div class="t">Open trades</div><div class="v" id="kOpen">0 / 5</div></div>
            <div class="k"><div class="t">Trava</div><div class="v" id="kLock">OFF</div></div>
          </div>
          <div class="kpi" style="margin-top:10px">
            <div class="k"><div class="t">Realizado (P/L)</div><div class="v" id="kRealized">$0.00</div></div>
            <div class="k"><div class="t">Ganho bruto</div><div class="v" id="kGrossWin">$0.00</div></div>
            <div class="k"><div class="t">Perda bruta</div><div class="v" id="kGrossLoss">$0.00</div></div>
            <div class="k"><div class="t">N√£o realizado</div><div class="v" id="kUnrealized">$0.00</div></div>
          </div>
        </div>

        <div class="card">
          <h2>Status</h2>
          <div class="kpi" style="grid-template-columns: repeat(2, minmax(0,1fr));">
  <div class="k"><div class="t">D√≥lar (USDT/BRL)</div><div class="v" id="kUsdBrl">‚Äî</div></div>
  <div class="k"><div class="t">Atualizado</div><div class="v" id="kUsdBrlTs">‚Äî</div></div>
</div>
          <div class="k" style="margin-top:10px">
            <div class="t">Detalhes</div>
            <div class="v mono" style="font-size:13px" id="kReasons">‚Äî</div>
          </div>

          <div class="k" style="margin-top:10px">
            <div class="t">Sinais por s√≠mbolo (top 12 por score)</div>
            <div id="multiTable"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="head" style="display:flex; align-items:center; justify-content:space-between; gap:10px">
        <h2 style="margin:0">Op√ß√µes (pendentes)</h2>
        <div class="small">Aparecem quando modo=ASK e score ‚àà [7,9)</div>
      </div>
      <div id="askList" class="list" style="margin-top:10px"></div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="head" style="display:flex; align-items:center; justify-content:space-between; gap:10px">
        <h2 style="margin:0">Open trades</h2>
        <div style="display:flex; gap:10px; align-items:center;">
          <button class="secondary" id="btnCloseAll" title="Fecha todas as opera√ß√µes pelo pre√ßo atual (market)">Fechar tudo (market)</button>
          <div class="tag" id="openCount">Ativos: 0 / 5</div>
        </div>
      </div>
      <div id="openList" class="list" style="margin-top:10px"></div>
    </div>

    <div class="card" style="margin-top:14px">
      <div class="head" style="display:flex; align-items:center; justify-content:space-between; gap:10px">
        <h2 style="margin:0">Logs</h2>
        <div class="small" id="lastTickSmall">‚Äî</div>
      </div>
      <div class="logs mono" id="logs"></div>
    </div>
  </div>

<script>
(() => {
  // =============================
  // CONSTANTS
  // =============================
  const MAX_CONSECUTIVE_LOSSES = 2;

  const SCORE_MIN = 7.0;
  const SCORE_AUTO_ON_ASK = 9.0;

  const MIN_TREND_STRENGTH = 0.0006; // abs(EMA9-EMA21)/Close >= 0.06%
  const MIN_ATR_PCT = 0.003;         // ATR/Close >= 0.30%

  // =============================
  // STATE
  // =============================
  const S = {
    runningProfile: null,
    runtimeCfg: null,
    testMode:false,
    running:false,
    timer:null,

    // ‚úÖ USD/BRL (proxy via USDTBRL)
    usdBrl: null,
    usdBrlTs: 0,
    usdTimer: null,

    dayAnchor: 100,
    cash:100,
    grossWinUsd:0,
    grossLossUsd:0,
    realizedUsd:0,
    wins:0,
    losses:0,
    lossStreak:0,

    locked:false,
    lockReason:'',

    lastTickTs:0,

    // ‚úÖ multi
    lastPrices: {},     // {BTCUSDT: 123}
    lastSignals: {},    // {BTCUSDT: 'BUY'}
    lastScores: {},     // {BTCUSDT: 8.12}
    lastReasonsMap: {}, // {BTCUSDT: ['...']}
    lastKlinesMap: {},  // {BTCUSDT: klinesArray}
    symbolsUniverse: [],

    pending:[],
    open:[],

    profile:'BALANCEADO',
    tradeGuard: new Set(),
  };

  // =============================
  // DOM
  // =============================
  const $ = (id) => document.getElementById(id);
  const el = {
    dot: $('dot'), runLabel: $('runLabel'), tickLabel: $('tickLabel'),
    btnStart: $('btnStart'), btnStop: $('btnStop'), btnOnce: $('btnOnce'), btnReset: $('btnReset'), btnUnlock: $('btnUnlock'), btnTestMode: $('btnTestMode'),
    lockBanner: $('lockBanner'), lockReason: $('lockReason'),

    kCash: $('kCash'), kEquity: $('kEquity'), kPL: $('kPL'), kDD: $('kDD'),
    kRealized: $('kRealized'), kGrossWin: $('kGrossWin'), kGrossLoss: $('kGrossLoss'), kUnrealized: $('kUnrealized'),
    kWL: $('kWL'), kStreak: $('kStreak'), kOpen: $('kOpen'), kLock: $('kLock'),

    // ‚úÖ status cards (agora d√≥lar + timestamp)
    kUsdBrl: $('kUsdBrl'),
    kUsdBrlTs: $('kUsdBrlTs'),

    // detalhes
    kPrice: $('kPrice'),           // mant√©m como ‚ÄúTick HH:MM:SS‚Äù
    kReasons: $('kReasons'),       // detalhes (top score, etc)

    askList: $('askList'), openList: $('openList'), openCount: $('openCount'),
    profileLabel: $('profileLabel'), profileHint: $('profileHint'), profileSeg: $('profileSeg'),
    logs: $('logs'), lastTickSmall: $('lastTickSmall'),
    multiTable: $('multiTable'),
  };

  // =============================
  // UTILS
  // =============================
  const now = () => Date.now();
  const fmtUSD = (n) => (Number(n)||0).toLocaleString('en-US',{style:'currency',currency:'USD',maximumFractionDigits:2});
  const fmtPct = (n) => `${(Number(n)||0).toFixed(2)}%`;
  const ts = (ms) => new Date(ms).toLocaleTimeString('pt-BR',{hour12:false});
  const uid = () => Math.random().toString(16).slice(2) + '-' + Math.random().toString(16).slice(2);
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function log(msg){
    const line = `[${ts(now())}] ${msg}`;
    const div = document.createElement('div');
    div.textContent = line;
    el.logs.prepend(div);
  }

  function intervalToMs(interval){
    const m = String(interval||'').trim();
    const unit = m.slice(-1);
    const n = Number(m.slice(0,-1));
    if (!Number.isFinite(n) || n <= 0) return 60_000;
    if (unit === 'm') return n * 60_000;
    if (unit === 'h') return n * 3_600_000;
    if (unit === 'd') return n * 86_400_000;
    if (unit === 'w') return n * 7 * 86_400_000;
    if (unit === 'M') return n * 30 * 86_400_000;
    return 60_000;
  }

  // =============================
  // TRADE GUARD
  // =============================
  function tradeKeyFromIdea(idea){
    return `${idea.signal}|${idea.symbol}|${idea.interval}|${idea.klineCloseTs||0}`;
  }
  function canPassTradeGuard(key){ return !S.tradeGuard.has(key); }
  function markTradeGuard(key){
    S.tradeGuard.add(key);
    if (S.tradeGuard.size > 2000){
      const arr = Array.from(S.tradeGuard);
      for (let i=0;i<1000;i++) S.tradeGuard.delete(arr[i]);
    }
  }

  // =============================
  // PROFILES
  // =============================
  const PROFILE_PRESETS = {
    CONSERVADOR: { name:'Conservador', riskPct: 1.0, maxDailyDD: 2.0, atrPeriod:14, atrStop: 2.4, atrTarget: 3.0, atrTrail: 2.2, breakEvenR: 1.5 },
    BALANCEADO:  { name:'Balanceado',  riskPct: 1.3, maxDailyDD: 3.0, atrPeriod:14, atrStop: 2.2, atrTarget: 3.2, atrTrail: 2.2, breakEvenR: 1.3 },
    AGRESSIVO:   { name:'Agressivo',   riskPct: 1.8, maxDailyDD: 5.0, atrPeriod:14, atrStop: 2.0, atrTarget: 3.6, atrTrail: 2.6, breakEvenR: 1.5 },
  };

  function setInput(id, value){
    const x = document.getElementById(id);
    if (x) x.value = String(value);
  }
  function applyProfileToInputs(prof){
    const p = PROFILE_PRESETS[prof] || PROFILE_PRESETS.BALANCEADO;
    setInput("cfgRiskPct", p.riskPct);
    setInput("cfgMaxDailyDD", p.maxDailyDD);
    setInput("cfgAtrPeriod", p.atrPeriod);
    setInput("cfgAtrStop", p.atrStop);
    setInput("cfgAtrTarget", p.atrTarget);
    setInput("cfgAtrTrail", p.atrTrail);
    setInput("cfgBreakEvenR", p.breakEvenR);
  }
  function setProfile(prof){
    const key = String(prof||'').toUpperCase();
    if (!PROFILE_PRESETS[key]) return;

    S.profile = key;
    applyProfileToInputs(key);

    if (el.profileSeg){
      el.profileSeg.querySelectorAll(".segbtn").forEach(b => {
        b.classList.toggle("active", b.getAttribute("data-prof") === key);
      });
    }
    if (el.profileHint) el.profileHint.textContent = `Ativo: ${PROFILE_PRESETS[key].name}`;
    log(`Perfil aplicado: ${PROFILE_PRESETS[key].name}`);
    updateUI();
  }

  // =============================
  // CONFIG (MULTI)
  // =============================
  function getSelectedSymbols(){
    const universe = document.getElementById('cfgUniverse')?.value || 'SINGLE';
    const sel = document.getElementById('cfgSymbols');

    if (universe === 'ALL_USDT'){
      const all = Array.isArray(S.symbolsUniverse) ? S.symbolsUniverse : [];
      const maxN = Math.max(5, Math.min(500, Number(document.getElementById('cfgMaxSymbolsAll')?.value || 40)));
      return (all.length ? all.slice(0, maxN) : ['BTCUSDT']);
    }

    const chosen = sel ? [...sel.selectedOptions].map(o => o.value) : ['BTCUSDT'];
    if (!chosen.length) return ['BTCUSDT'];

    if (universe === 'SINGLE') return [chosen[0]];
    return chosen;
  }

  function getCfg(){
    const symbols = getSelectedSymbols();

    const interval = document.getElementById('cfgInterval').value;
    const loopSec = Math.max(2, Number(document.getElementById('cfgLoopSec').value||10));
    const limit = Math.max(60, Math.min(1000, Number(document.getElementById('cfgLimit').value||300)));
    const mode = document.getElementById('cfgMode').value;

    const noRepeat = ((document.getElementById('cfgNoRepeat')?.value || 'ON') === 'ON');

    const riskPct = Math.max(1, Math.min(2, Number(document.getElementById('cfgRiskPct').value||1.3)));
    const maxOpen = Math.max(1, Math.min(20, Number(document.getElementById('cfgMaxOpen').value||5)));
    const maxDailyDD = Math.max(0.5, Math.min(99, Number(document.getElementById('cfgMaxDailyDD').value||3)));

    const atrPeriod = Math.max(7, Math.min(50, Number(document.getElementById('cfgAtrPeriod').value||14)));
    const atrStop = Math.max(0.2, Math.min(10, Number(document.getElementById('cfgAtrStop').value||2.2)));
    const atrTarget = Math.max(0.5, Math.min(20, Number(document.getElementById('cfgAtrTarget').value||3.2)));
    const atrTrail = Math.max(0, Math.min(20, Number(document.getElementById('cfgAtrTrail').value||2.2)));
    const breakEvenR = Math.max(0, Math.min(10, Number(document.getElementById('cfgBreakEvenR').value||1.3)));

    const timeStopOn = ((document.getElementById('cfgTimeStopOn')?.value || 'OFF') === 'ON');
    const timeStopCandles = Math.max(1, Math.min(50, Number(document.getElementById('cfgTimeStopCandles')?.value || 6)));

    const partialOn = ((document.getElementById('cfgPartialOn')?.value || 'OFF') === 'ON');
    const partialAtR = Math.max(0.1, Math.min(10, Number(document.getElementById('cfgPartialAtR')?.value || 1.0)));
    const partialPct = Math.max(1, Math.min(99, Number(document.getElementById('cfgPartialPct')?.value || 50))) / 100;

    const beAfterPartialOn = ((document.getElementById('cfgBEAfterPartialOn')?.value || 'OFF') === 'ON');

    const perSymbolDelayMs = Math.max(0, Math.min(500, Number(document.getElementById('cfgPerSymbolDelayMs')?.value || 35)));

    return {
      symbols, interval, loopSec, limit, mode, noRepeat,
      riskPct, maxOpen, maxDailyDD,
      atrPeriod, atrStop, atrTarget, atrTrail, breakEvenR,
      timeStopOn, timeStopCandles,
      partialOn, partialAtR, partialPct,
      beAfterPartialOn,
      profile: S.profile,
      universe: document.getElementById('cfgUniverse')?.value || 'SINGLE',
      perSymbolDelayMs
    };
  }

  // =============================
  // INDICATORS
  // =============================
  const SMA = (arr, p) => {
    const out = new Array(arr.length).fill(null);
    if (arr.length < p) return out;
    let sum = 0;
    for (let i=0;i<arr.length;i++){
      sum += arr[i];
      if (i>=p) sum -= arr[i-p];
      if (i>=p-1) out[i]=sum/p;
    }
    return out;
  };

  const EMA = (arr, p) => {
    const out = new Array(arr.length).fill(null);
    if (arr.length < p) return out;
    const k = 2/(p+1);
    let sum=0;
    for (let i=0;i<p;i++) sum += arr[i];
    let ema = sum/p;
    out[p-1]=ema;
    for (let i=p;i<arr.length;i++){
      ema = arr[i]*k + ema*(1-k);
      out[i]=ema;
    }
    return out;
  };

  function RSI(closes, p=14){
    if (closes.length < p+1) return null;
    let gains=0, losses=0;
    for (let i=1;i<=p;i++){
      const d = closes[i]-closes[i-1];
      if (d>=0) gains += d; else losses += Math.abs(d);
    }
    let avgG = gains/p, avgL = losses/p;
    for (let i=p+1;i<closes.length;i++){
      const d = closes[i]-closes[i-1];
      const g = d>0? d:0;
      const l = d<0? Math.abs(d):0;
      avgG = (avgG*(p-1) + g)/p;
      avgL = (avgL*(p-1) + l)/p;
    }
    if (avgL === 0) return 100;
    const rs = avgG/avgL;
    return 100 - (100/(1+rs));
  }

  function ATR(highs, lows, closes, p=14){
    if (closes.length < p+1) return null;
    const trs=[];
    for (let i=1;i<closes.length;i++){
      const h = highs[i], l=lows[i], pc=closes[i-1];
      const tr = Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc));
      trs.push(tr);
    }
    if (trs.length < p) return null;
    let sum=0;
    for (let i=0;i<p;i++) sum += trs[i];
    let atr = sum/p;
    for (let i=p;i<trs.length;i++){
      atr = (atr*(p-1) + trs[i])/p;
    }
    return atr;
  }

  // =============================
  // DATA (timeout + exchangeInfo + USDTBRL)
  // =============================
  async function fetchJsonWithTimeout(url, timeoutMs=9000){
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try{
      const res = await fetch(url, {signal: ctrl.signal});
      return res;
    } finally {
      clearTimeout(t);
    }
  }

  async function fetchKlines(symbol, interval, limit){
    const url = `https://api.binance.com/api/v3/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${encodeURIComponent(limit)}`;
    const res = await fetchJsonWithTimeout(url, 9000);
    if (!res.ok) throw new Error(`Binance HTTP ${res.status}`);
    const data = await res.json();
    if (!Array.isArray(data)) throw new Error('Resposta inv√°lida de klines');
    return data;
  }

  async function fetchExchangeInfoUSDT(){
    const url = `https://api.binance.com/api/v3/exchangeInfo`;
    const res = await fetchJsonWithTimeout(url, 12000);
    if (!res.ok) throw new Error(`exchangeInfo HTTP ${res.status}`);
    const data = await res.json();
    const symbols = (data.symbols || [])
      .filter(s =>
        s.status === 'TRADING' &&
        s.quoteAsset === 'USDT' &&
        s.isSpotTradingAllowed === true
      )
      .map(s => s.symbol);
    return symbols;
  }

  function populateSymbolsSelect(symbols){
    const sel = document.getElementById('cfgSymbols');
    if (!sel) return;

    const currentSelected = new Set([...sel.selectedOptions].map(o => o.value));
    sel.innerHTML = '';

    const preferred = ['BTCUSDT','ETHUSDT','BNBUSDT','SOLUSDT','XRPUSDT','ADAUSDT','DOGEUSDT','LINKUSDT','AVAXUSDT','MATICUSDT'];
    const ordered = [
      ...preferred.filter(x => symbols.includes(x)),
      ...symbols.filter(x => !preferred.includes(x))
    ];

    for (const sym of ordered){
      const opt = document.createElement('option');
      opt.value = sym;
      opt.textContent = sym;
      if (currentSelected.has(sym) || (currentSelected.size===0 && sym==='BTCUSDT')) opt.selected = true;
      sel.appendChild(opt);
    }
  }

  function parseKlines(kl){
    const o=[],h=[],l=[],c=[],v=[],t=[];
    for (const k of kl){
      t.push(Number(k[0]));
      o.push(Number(k[1]));
      h.push(Number(k[2]));
      l.push(Number(k[3]));
      c.push(Number(k[4]));
      v.push(Number(k[5]));
    }
    return {t,o,h,l,c,v};
  }

  // ‚úÖ USD/BRL via USDTBRL (proxy)
  async function fetchUSDTBRL(){
    const url = `https://api.binance.com/api/v3/ticker/price?symbol=USDTBRL`;
    const res = await fetchJsonWithTimeout(url, 8000);
    if (!res.ok) throw new Error(`USDTBRL HTTP ${res.status}`);
    const data = await res.json();
    const p = Number(data?.price);
    if (!Number.isFinite(p)) throw new Error('Pre√ßo USDTBRL inv√°lido');
    return p;
  }

  async function updateUsdBrl(){
    try{
      const p = await fetchUSDTBRL();
      S.usdBrl = p;
      S.usdBrlTs = now();
    }catch(e){
      // sem log pra n√£o poluir
    }
  }

  // =============================
  // STRATEGY (Op√ß√£o 2)
  // =============================
  function buildDecision(series){
    const closes = series.c;
    const highs = series.h;
    const lows = series.l;
    const n = closes.length - 1;
    const last = closes[n];
    const cfg = getCfg();

    const ema9 = EMA(closes, 9);
    const ema21 = EMA(closes, 21);
    const ma200 = SMA(closes, 200);
    const rsi14 = RSI(closes, 14);
    const atr = ATR(highs, lows, closes, cfg.atrPeriod);

    const e9 = ema9[n];
    const e21 = ema21[n];
    const m200 = ma200[n];

    const reasons = [];
    let score = 0;

    const hasM200 = (m200 != null);
    const bullRegime = hasM200 ? (last > m200) : false;
    const bearRegime = hasM200 ? (last < m200) : false;
    reasons.push(hasM200 ? (bullRegime ? "REGIME=BULL" : "REGIME=BEAR") : "MA200:insuf");

    let trendStrength = 0;
    if (e9 != null && e21 != null){
      trendStrength = Math.abs(e9 - e21) / Math.max(1e-9, last);
      reasons.push(e9 > e21 ? "EMA9>EMA21" : "EMA9<EMA21");
      reasons.push(`TS=${(trendStrength*100).toFixed(2)}%`);
      score += Math.min(4, 2.2 + (trendStrength / 0.002) * 1.8);
    } else {
      reasons.push("EMA:insuf");
      score += 1.0;
    }

    const atrPct = (typeof atr === 'number') ? (atr / Math.max(1e-9, last)) : 0;
    if (typeof atr === 'number'){
      reasons.push(`ATR%=${(atrPct*100).toFixed(2)}%`);
      const volN = Math.max(0, Math.min(1, (atrPct - 0.003) / (0.012 - 0.003)));
      score += volN * 2.0;
    } else {
      reasons.push("ATR:insuf");
      score += 0.4;
    }

    if (typeof rsi14 === 'number'){
      reasons.push(`RSI14=${rsi14.toFixed(1)}`);
      const okBand = (rsi14 >= 40 && rsi14 <= 75);
      score += okBand ? 1.8 : 0.8;
    } else {
      reasons.push("RSI:insuf");
      score += 0.8;
    }

    if (hasM200){
      const dist = Math.abs(last - m200) / Math.max(1e-9, last);
      const regPts = Math.min(2.0, 0.8 + dist * 8);
      score += regPts;
      reasons.push(`MA200D=${(dist*100).toFixed(2)}%`);
    }

    if (closes.length >= 6){
      const r5 = (closes[n] - closes[n-5]) / Math.max(1e-9, closes[n-5]);
      const pts = Math.min(1.0, Math.abs(r5) * 25);
      score += pts;
      reasons.push(`Mom5=${(r5*100).toFixed(2)}%`);
    }

    if (S.testMode){
      score = Math.min(10, score + 1.5);
      reasons.push("TEST:+1.5");
    }

    score = Math.max(0, Math.min(10, score));

    let signal = 'HOLD';
    const okTrend = trendStrength >= MIN_TREND_STRENGTH;
    const okVol = atrPct >= MIN_ATR_PCT;

    const okCore =
      (score >= SCORE_MIN) &&
      okTrend &&
      okVol &&
      hasM200 &&
      (e9 != null && e21 != null) &&
      (typeof rsi14 === 'number') &&
      (typeof atr === 'number');

    if (okCore){
      if (bullRegime) signal = 'BUY';
      else if (bearRegime) signal = 'SELL';
      else signal = 'HOLD';
    }

    if (!okTrend) reasons.push("FILTER:TrendWeak");
    if (!okVol) reasons.push("FILTER:LowVol");

    return {
      last, score, signal, reasons,
      atr: (typeof atr === 'number' ? atr : null),
      rsi14, ema9:e9, ema21:e21, ma200:m200,
      trendStrength, atrPct,
      bullRegime, bearRegime
    };
  }

  // =============================
  // RISK / PAPER EXECUTION
  // =============================
  function calcPositionQty(entry, stop, riskUsd){
    const dist = Math.max(1e-9, Math.abs(entry-stop));
    return riskUsd / dist;
  }

  function computeEquity(){
    let eq = S.cash;
    for (const t of S.open){
      const p = S.lastPrices[t.symbol];
      if (typeof p === 'number'){
        const dir = t.side === 'BUY' ? 1 : -1;
        eq += dir * (p - t.entry) * t.qty;
      }
    }
    return eq;
  }

  function canTrade(cfg){
    if (S.locked) return { ok:false, reason: S.lockReason || 'Sistema travado' };

    const equity = computeEquity();
    const dd = Math.max(0, (S.dayAnchor - equity) / Math.max(1e-9, S.dayAnchor) * 100);
    if (dd >= cfg.maxDailyDD) return { ok:false, reason: `Daily DD ${dd.toFixed(2)}% ‚â• limite ${cfg.maxDailyDD}%` };

    if (S.open.length >= cfg.maxOpen) return { ok:false, reason: `Limite de trades abertos atingido (${cfg.maxOpen})` };

    return { ok:true };
  }

  function openTradeFromIdea(idea, cfg, riskMult = 1.0){
    const id = uid();
    const riskUsd = S.cash * (cfg.riskPct/100) * riskMult;
    const qty = calcPositionQty(idea.entry, idea.stop, riskUsd);

    const trade = {
      id,
      openedAt: now(),
      openedKlineTs: idea.klineCloseTs || now(),
      side: idea.signal,
      symbol: idea.symbol,
      interval: idea.interval,
      entry: idea.entry,
      stop: idea.stop,
      target: idea.target,
      qty,
      riskUsd,
      atr: idea.atr,
      trailOn: cfg.atrTrail > 0,
      trailMult: cfg.atrTrail,
      breakEvenR: cfg.breakEvenR,
      movedBE: false,
      peak: idea.entry,
      reasons: idea.reasons,
      riskMult,
      partialDone: false,
    };
    S.open.push(trade);
    log(`OPEN ${trade.side} ${trade.symbol} @ ${trade.entry.toFixed(4)} | stop ${trade.stop.toFixed(4)} | target ${trade.target.toFixed(4)} | qty ${trade.qty.toFixed(6)} | score ${idea.score.toFixed(2)} | RISKx ${riskMult.toFixed(2)}x`);
  }

  function applyPnL(qty, side, entry, exitPrice){
    const dir = side === 'BUY' ? 1 : -1;
    return dir * (exitPrice - entry) * qty;
  }

  function bookRealized(pnl){
    S.cash += pnl;
    if (pnl >= 0) S.grossWinUsd += pnl;
    else S.grossLossUsd += Math.abs(pnl);
    S.realizedUsd += pnl;

    const EPS = 1e-9;
    if (pnl > EPS){
      S.wins += 1;
      S.lossStreak = 0;
    } else if (pnl < -EPS){
      S.losses += 1;
      S.lossStreak += 1;
      if (S.lossStreak >= MAX_CONSECUTIVE_LOSSES){
        S.locked = true;
        S.lockReason = `Bloqueado ap√≥s ${MAX_CONSECUTIVE_LOSSES} Loss consecutivos.`;
        log(`üîí TRAVA ativada: ${MAX_CONSECUTIVE_LOSSES} losses consecutivos.`);
      }
    } else {
      S.lossStreak = 0;
    }
  }

  function closeTrade(trade, exitPrice, reason){
    const pnl = applyPnL(trade.qty, trade.side, trade.entry, exitPrice);
    bookRealized(pnl);
    S.open = S.open.filter(t => t.id !== trade.id);
    log(`CLOSE ${trade.side} ${trade.symbol} @ ${exitPrice.toFixed(4)} | PnL ${fmtUSD(pnl)} | ${reason}`);
  }

  function closePartial(trade, exitPrice, pct, reason){
    const pctClamped = Math.max(0.01, Math.min(0.99, pct));
    const qtyClose = trade.qty * pctClamped;
    if (qtyClose <= 1e-12) return;

    const pnl = applyPnL(qtyClose, trade.side, trade.entry, exitPrice);
    bookRealized(pnl);

    trade.qty = trade.qty - qtyClose;
    trade.riskUsd = trade.riskUsd * (1 - pctClamped);

    log(`PARTIAL ${trade.side} ${trade.symbol} @ ${exitPrice.toFixed(4)} | ${Math.round(pctClamped*100)}% | PnL ${fmtUSD(pnl)} | ${reason}`);

    if (trade.qty <= 1e-10){
      S.open = S.open.filter(t => t.id !== trade.id);
      log(`CLOSE (tiny) ${trade.side} ${trade.symbol} | posi√ß√£o residual removida`);
    }
  }

  function closeTradeByIdMarket(id){
    const t = S.open.find(x => x.id === id);
    if (!t) return;
    const price = S.lastPrices[t.symbol];
    if (typeof price !== 'number') { log(`‚ùå Sem pre√ßo atual de ${t.symbol} para fechar em market.`); return; }
    closeTrade(t, price, 'MANUAL (market)');
    updateUI();
  }

  function closeAllOpenMarket(){
    const ids = S.open.map(x => x.id);
    if (!ids.length) { log('Nenhuma opera√ß√£o aberta para fechar.'); return; }
    for (const id of ids){
      const t = S.open.find(x => x.id === id);
      if (!t) continue;
      const price = S.lastPrices[t.symbol];
      if (typeof price !== 'number') { log(`‚ö†Ô∏è Sem pre√ßo de ${t.symbol}, pulando fechamento.`); continue; }
      closeTrade(t, price, 'MANUAL ALL (market)');
    }
    updateUI();
  }

  function updateOpenTrades(cfg, currentKlineTs){
    const barMs = intervalToMs(cfg.interval);

    for (const t of [...S.open]){
      const price = S.lastPrices[t.symbol];
      if (typeof price !== 'number') continue;

      if (t.side === 'BUY') t.peak = Math.max(t.peak, price);
      else t.peak = Math.min(t.peak, price);

      const denom = Math.max(1e-9, Math.abs(t.entry - t.stop));
      const r = Math.abs(price - t.entry) / denom;

      if (cfg.partialOn && !t.partialDone && r >= cfg.partialAtR){
        closePartial(t, price, cfg.partialPct, `R>=${cfg.partialAtR.toFixed(1)}`);
        t.partialDone = true;

        if (cfg.beAfterPartialOn){
          t.stop = t.entry;
          t.movedBE = true;
          log(`BE ap√≥s parcial: stop -> entry (${t.side} ${t.symbol})`);
        }
      }

      if (!t.movedBE && cfg.breakEvenR > 0 && r >= cfg.breakEvenR){
        t.stop = t.entry;
        t.movedBE = true;
        log(`BE: stop -> entry (${t.side} ${t.symbol})`);
      }

      if (t.trailOn && t.atr && t.trailMult > 0){
        const trailDist = t.atr * t.trailMult;
        if (t.side === 'BUY'){
          const newStop = t.peak - trailDist;
          if (newStop > t.stop) t.stop = newStop;
        } else {
          const newStop = t.peak + trailDist;
          if (newStop < t.stop) t.stop = newStop;
        }
      }

      if (cfg.timeStopOn && typeof currentKlineTs === 'number' && typeof t.openedKlineTs === 'number'){
        const bars = Math.floor((currentKlineTs - t.openedKlineTs) / Math.max(1, barMs));
        if (bars >= cfg.timeStopCandles){
          closeTrade(t, price, `TIME_STOP ${bars}c>=${cfg.timeStopCandles}c`);
          continue;
        }
      }

      if (t.side === 'BUY'){
        if (price <= t.stop) closeTrade(t, t.stop, 'STOP');
        else if (price >= t.target) closeTrade(t, t.target, 'TARGET');
      } else {
        if (price >= t.stop) closeTrade(t, t.stop, 'STOP');
        else if (price <= t.target) closeTrade(t, t.target, 'TARGET');
      }
    }
  }

  // =============================
  // PENDING (ASK)
  // =============================
  function addPending(idea){
    const key = tradeKeyFromIdea(idea);
    if (S.pending.some(p => p.key === key)) return;
    S.pending.unshift({ ...idea, id: uid(), createdAt: now(), key });
    if (S.pending.length > 20) S.pending.pop();
    log(`ASK: ${idea.signal} ${idea.symbol} score ${idea.score.toFixed(2)} (pendente)`);
  }

  function acceptPending(id){
    const cfg = S.runtimeCfg || getCfg();
    const p = S.pending.find(x => x.id === id);
    if (!p) return;

    const gate = canTrade(cfg);
    if (!gate.ok){
      log(`‚ùå Aceite recusado: ${gate.reason}`);
      return;
    }

    if (cfg.noRepeat && !canPassTradeGuard(p.key)){
      log(`üõë Aceite bloqueado (repetido): ${p.key}`);
      return;
    }

    openTradeFromIdea(p, cfg, p.riskMult ?? 1.0);
    markTradeGuard(p.key);

    S.pending = S.pending.filter(x => x.id !== id);
    updateUI();
  }

  function rejectPending(id){
    const p = S.pending.find(x => x.id === id);
    if (p) log(`ASK rejeitado: ${p.signal} ${p.symbol} score ${p.score.toFixed(2)}`);
    S.pending = S.pending.filter(x => x.id !== id);
    updateUI();
  }

  // =============================
  // LOOP (MULTI SYMBOL)
  // =============================
  async function tick(){
    const cfg = getCfg();

    const d = new Date();
    const dayKey = `${d.getFullYear()}-${d.getMonth()+1}-${d.getDate()}`;
    if (S._dayKey !== dayKey){
      S._dayKey = dayKey;
      S.dayAnchor = computeEquity();
      log(`Novo dia: anchor de equity = ${fmtUSD(S.dayAnchor)}`);
    }

    S.lastTickTs = now();
    el.tickLabel.textContent = `√öltimo tick: ${ts(S.lastTickTs)}`;
    el.lastTickSmall.textContent = el.tickLabel.textContent;

    const gate0 = canTrade(cfg);
    if (!gate0.ok){
      S.lockReason = gate0.reason;
      updateUI();
      return;
    }

    const symbols = cfg.symbols || [];
    if (!symbols.length){
      log("‚ö†Ô∏è Nenhum s√≠mbolo selecionado.");
      updateUI();
      return;
    }

    for (const symbol of symbols){
      try {
        const kl = await fetchKlines(symbol, cfg.interval, cfg.limit);
        S.lastKlinesMap[symbol] = kl;

        const series = parseKlines(kl);
        const currentKlineTs = series.t[series.t.length-1] || now();

        const dec = buildDecision(series);

        S.lastPrices[symbol] = dec.last;
        S.lastSignals[symbol] = dec.signal;
        S.lastScores[symbol] = dec.score;
        S.lastReasonsMap[symbol] = dec.reasons;

        // ‚úÖ gerencia trades abertos (mesmo se HOLD)
        updateOpenTrades(cfg, currentKlineTs);

        const gate = canTrade(cfg);
        if (!gate.ok){
          S.lockReason = gate.reason;
          break;
        }

        // ‚úÖ HOLD => n√£o entra
        if (dec.signal === 'HOLD' || !dec.atr || dec.score < SCORE_MIN){
          if (cfg.perSymbolDelayMs) await sleep(cfg.perSymbolDelayMs);
          continue;
        }

        let riskMult = 1.0;
        if (dec.bullRegime && dec.ema9 != null && dec.ema21 != null && dec.ema9 < dec.ema21) riskMult = 0.5;
        if (dec.bearRegime && dec.ema9 != null && dec.ema21 != null && dec.ema9 > dec.ema21) riskMult = 0.5;

        const entry = dec.last;
        const stopDist = dec.atr * cfg.atrStop;
        const targetDist = dec.atr * cfg.atrTarget;
        const stop = dec.signal === 'BUY' ? (entry - stopDist) : (entry + stopDist);
        const target = dec.signal === 'BUY' ? (entry + targetDist) : (entry - targetDist);

        const idea = {
          signal: dec.signal,
          score: dec.score,
          symbol,
          interval: cfg.interval,
          entry,
          stop,
          target,
          atr: dec.atr,
          reasons: [...dec.reasons, `RISKx=${riskMult.toFixed(2)}`],
          riskMult,
          klineCloseTs: currentKlineTs,
        };

        const key = tradeKeyFromIdea(idea);

        if (cfg.noRepeat && !canPassTradeGuard(key)){
          log(`üõë Trade repetido bloqueado (guard): ${key}`);
          if (cfg.perSymbolDelayMs) await sleep(cfg.perSymbolDelayMs);
          continue;
        }

        if (cfg.mode === 'AUTO') {
          openTradeFromIdea(idea, cfg, riskMult);
          markTradeGuard(key);
        } else {
          if (dec.score >= SCORE_AUTO_ON_ASK) {
            openTradeFromIdea(idea, cfg, riskMult);
            markTradeGuard(key);
          } else {
            addPending(idea);
            // ‚úÖ n√£o marca guard aqui para permitir aceitar depois
          }
        }

        if (cfg.perSymbolDelayMs) await sleep(cfg.perSymbolDelayMs);
      } catch (e){
        log(`Erro tick (${symbol}): ${e?.message || String(e)}`);
        if (cfg.perSymbolDelayMs) await sleep(cfg.perSymbolDelayMs);
      }
    }

    updateUI();
  }

  // =============================
  // UI
  // =============================
  function renderMultiTable(cfg){
    const symbols = cfg.symbols || [];
    const rows = symbols
      .map(s => ({
        symbol: s,
        signal: S.lastSignals[s] || '‚Äî',
        score: (typeof S.lastScores[s] === 'number') ? S.lastScores[s] : null,
        price: (typeof S.lastPrices[s] === 'number') ? S.lastPrices[s] : null,
      }))
      .filter(r => r.score != null)
      .sort((a,b) => (b.score - a.score))
      .slice(0, 12);

    if (!rows.length){
      el.multiTable.innerHTML = `<div class="muted">Ainda sem dados. Clique em "Rodar 1x" ou "Ligar Rob√¥".</div>`;
      return;
    }

    const html = `
      <table class="table">
        <thead>
          <tr>
            <th>Symbol</th><th>Sinal</th><th>Score</th><th>Pre√ßo</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => {
            const cls = r.signal === 'BUY' ? 'buy' : (r.signal === 'SELL' ? 'sell' : 'hold');
            return `
              <tr>
                <td class="mono">${r.symbol}</td>
                <td><span class="tag ${cls}">${r.signal}</span></td>
                <td class="mono">${r.score.toFixed(2)}</td>
                <td class="mono">${r.price != null ? r.price.toFixed(4) : '‚Äî'}</td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
    `;
    el.multiTable.innerHTML = html;
  }

  function updateUI(){
    const cfg = getCfg();
    const equity = computeEquity();
    const pl = equity - 100;
    const dd = Math.max(0, (S.dayAnchor - equity) / Math.max(1e-9, S.dayAnchor) * 100);

    el.kCash.textContent = fmtUSD(S.cash);
    el.kEquity.textContent = fmtUSD(equity);
    el.kPL.textContent = fmtUSD(pl);

    const unrealized = equity - S.cash;
    el.kRealized.textContent = fmtUSD(S.realizedUsd);
    el.kGrossWin.textContent = fmtUSD(S.grossWinUsd);
    el.kGrossLoss.textContent = fmtUSD(S.grossLossUsd);
    el.kUnrealized.textContent = fmtUSD(unrealized);

    el.kDD.textContent = fmtPct(dd);
    el.kWL.textContent = `${S.wins} / ${S.losses}`;
    el.kStreak.textContent = String(S.lossStreak);
    el.kOpen.textContent = `${S.open.length} / ${cfg.maxOpen}`;
    el.openCount.textContent = `Ativos: ${S.open.length} / ${cfg.maxOpen}`;

    const shouldLock = S.locked || dd >= cfg.maxDailyDD;
    if (dd >= cfg.maxDailyDD){
      S.locked = true;
      S.lockReason = `Daily DD ${dd.toFixed(2)}% ‚â• limite ${cfg.maxDailyDD}%`;
    }

    el.kLock.textContent = shouldLock ? 'ON' : 'OFF';
    el.lockBanner.classList.toggle('on', shouldLock);
    el.lockReason.textContent = S.lockReason || 'Bloqueado por regra de seguran√ßa.';

    el.dot.className = `dot ${S.running ? 'on' : 'off'}`;
    el.runLabel.textContent = `Loop: ${S.running ? 'ON' : 'OFF'}`;

    const profName = (PROFILE_PRESETS[S.runningProfile]?.name) || '-';
    el.profileLabel.textContent = `Perfil (rodando): ${S.running ? profName : '-'}`;

    // ‚úÖ Card do d√≥lar (sem HOLD)
    if (el.kUsdBrl){
      el.kUsdBrl.textContent = (typeof S.usdBrl === 'number') ? `R$ ${S.usdBrl.toFixed(4)}` : '‚Äî';
    }
    if (el.kUsdBrlTs){
      el.kUsdBrlTs.textContent = S.usdBrlTs ? ts(S.usdBrlTs) : '‚Äî';
    }

    // ‚úÖ ‚ÄúTick‚Äù continua no outro card
    el.kPrice.textContent = `Tick ${ts(S.lastTickTs || now())}`;

    // ‚úÖ Detalhes: mostra s√≥ trades abertos (o que "entrou"), sem HOLD
    const openBuy = S.open.filter(t => t.side === 'BUY').length;
    const openSell = S.open.filter(t => t.side === 'SELL').length;

    const openSyms = [...new Set(S.open.map(t => t.symbol))];
    const openSymsTxt = openSyms.length ? openSyms.join(', ') : 'nenhum';

    el.kReasons.textContent =
      `Entradas abertas: BUY ${openBuy} ¬∑ SELL ${openSell} | S√≠mbolos: ${openSymsTxt}`;

    renderPending();
    renderOpen();
    renderMultiTable(cfg);

    el.btnTestMode.textContent = `Modo Teste: ${S.testMode ? 'ON' : 'OFF'}`;
    el.btnStart.disabled = S.running;
    el.btnStop.disabled = !S.running;
  }

  function renderPending(){
    el.askList.innerHTML = '';
    if (!S.pending.length){
      const empty = document.createElement('div');
      empty.className = 'item';
      empty.innerHTML = `<div class="head"><div><b>Nenhuma op√ß√£o pendente.</b><div class="small">No modo ASK, score ‚àà [7,9) aparece aqui.</div></div></div>`;
      el.askList.appendChild(empty);
      return;
    }

    for (const p of S.pending){
      const div = document.createElement('div');
      div.className = 'item';
      const tagClass = p.signal === 'BUY' ? 'buy' : 'sell';
      div.innerHTML = `
        <div class="head">
          <div>
            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
              <span class="tag ask">ASK</span>
              <span class="tag ${tagClass}">${p.signal}</span>
              <span class="small">${p.symbol} ¬∑ ${p.interval} ¬∑ score <b>${p.score.toFixed(2)}</b> ¬∑ <b class="mono">${(p.riskMult ?? 1).toFixed(2)}x</b></span>
            </div>
            <div class="small" style="margin-top:6px">Entry: <b class="mono">${p.entry.toFixed(4)}</b> ¬∑ Stop: <b class="mono">${p.stop.toFixed(4)}</b> ¬∑ Target: <b class="mono">${p.target.toFixed(4)}</b> ¬∑ ATR: <b class="mono">${p.atr.toFixed(4)}</b></div>
            <div class="small mono" style="margin-top:6px; opacity:.9">Motivos: ${p.reasons.join(' | ')}</div>
          </div>
          <div class="btns">
            <button class="secondary" data-act="reject" data-id="${p.id}">Rejeitar</button>
            <button data-act="accept" data-id="${p.id}">Aceitar</button>
          </div>
        </div>
      `;
      el.askList.appendChild(div);
    }

    el.askList.querySelectorAll('button[data-act]').forEach(btn => {
      btn.addEventListener('click', () => {
        const act = btn.getAttribute('data-act');
        const id = btn.getAttribute('data-id');
        if (act === 'accept') acceptPending(id);
        else rejectPending(id);
      });
    });
  }

  function renderOpen(){
    const cfg = getCfg();
    el.openList.innerHTML = '';
    if (!S.open.length){
      const empty = document.createElement('div');
      empty.className = 'item';
      empty.innerHTML = `<div class="head"><div><b>Nenhuma opera√ß√£o aberta.</b><div class="small">Trades em andamento aparecem aqui.</div></div></div>`;
      el.openList.appendChild(empty);
      return;
    }

    for (const t of S.open){
      const price = S.lastPrices[t.symbol];
      const dir = t.side === 'BUY' ? 1 : -1;
      const upnl = (typeof price === 'number') ? dir * (price - t.entry) * t.qty : 0;
      const rr = Math.abs(t.target - t.entry) / Math.max(1e-9, Math.abs(t.entry - t.stop));
      const tagClass = t.side === 'BUY' ? 'buy' : 'sell';

      const barMs = intervalToMs(cfg.interval);
      const lastK = S.lastKlinesMap[t.symbol];
      const currentTs = (lastK && Array.isArray(lastK) && lastK.length) ? Number(lastK[lastK.length-1]?.[0]) : null;
      let barsOpen = null;
      if (typeof currentTs === 'number' && typeof t.openedKlineTs === 'number'){
        barsOpen = Math.floor((currentTs - t.openedKlineTs) / Math.max(1, barMs));
      }

      const div = document.createElement('div');
      div.className = 'item';
      div.innerHTML = `
        <div class="head">
          <div>
            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
              <span class="tag ${tagClass}">${t.side}</span>
              <span class="small">${t.symbol} ¬∑ ${t.interval} ¬∑ qty <b class="mono">${t.qty.toFixed(6)}</b></span>
              <span class="small">R/R <b class="mono">${rr.toFixed(2)}</b></span>
              <span class="small">uPnL <b class="mono">${fmtUSD(upnl)}</b></span>
              <span class="small">RISKx <b class="mono">${(t.riskMult ?? 1).toFixed(2)}</b></span>
              ${barsOpen != null ? `<span class="small">bars <b class="mono">${barsOpen}</b></span>` : ``}
              ${t.partialDone ? `<span class="tag">partial OK</span>` : ``}
            </div>
            <div class="small" style="margin-top:6px">Entry: <b class="mono">${t.entry.toFixed(4)}</b> ¬∑ Stop: <b class="mono">${t.stop.toFixed(4)}</b> ¬∑ Target: <b class="mono">${t.target.toFixed(4)}</b></div>
            <div class="small" style="margin-top:6px">Trailing: <b>${t.trailOn ? 'ON' : 'OFF'}</b> ¬∑ BE: <b>${t.movedBE ? 'OK' : '‚Äî'}</b> ¬∑ Risk: <b class="mono">${fmtUSD(t.riskUsd)}</b></div>
          </div>
          <div style="display:flex; gap:10px; align-items:center; justify-content:flex-end;">
            <button class="secondary" data-act="close" data-id="${t.id}">Fechar (market)</button>
            <div class="tag">aberta ${ts(t.openedAt)}</div>
          </div>
        </div>
      `;
      el.openList.appendChild(div);
    }

    el.openList.querySelectorAll('button[data-act="close"]').forEach(btn => {
      btn.addEventListener('click', () => closeTradeByIdMarket(btn.getAttribute('data-id')));
    });
  }

  // =============================
  // CONTROLS
  // =============================
  function start(){
    if (S.running) return;
    S.runtimeCfg = getCfg();
    S.runningProfile = S.profile;
    S.running = true;

    // ‚úÖ liga timer do d√≥lar se ainda n√£o existir
    if (!S.usdTimer){
      updateUsdBrl();
      S.usdTimer = setInterval(updateUsdBrl, 10_000);
    }

    log(`Rob√¥ ligado. Loop: ${S.runtimeCfg.loopSec}s | Modo: ${S.runtimeCfg.mode} | Perfil: ${PROFILE_PRESETS[S.runningProfile].name} | S√≠mbolos: ${S.runtimeCfg.symbols.length}`);
    tick();
    S.timer = setInterval(tick, S.runtimeCfg.loopSec*1000);
    updateUI();
  }

  function stop(){
    if (!S.running) return;
    S.running = false;
    S.runtimeCfg = null;
    S.runningProfile = null;
    if (S.timer) clearInterval(S.timer);
    S.timer = null;
    log('Rob√¥ parado.');
    updateUI();
  }

  function resetAll(){
    stop();
    S.cash = 100;
    S.grossWinUsd = 0;
    S.grossLossUsd = 0;
    S.realizedUsd = 0;
    S.wins = 0;
    S.losses = 0;
    S.lossStreak = 0;
    S.locked = false;
    S.lockReason = '';
    S.pending = [];
    S.open = [];
    S.dayAnchor = 100;
    S._dayKey = null;
    S.tradeGuard.clear();

    S.lastPrices = {};
    S.lastSignals = {};
    S.lastScores = {};
    S.lastReasonsMap = {};
    S.lastKlinesMap = {};

    el.logs.innerHTML = '';
    log('Reset geral completo.');
    updateUI();
  }

  function unlockSafety(){
    S.locked = false;
    S.lossStreak = 0;
    S.lockReason = '';
    log('Trava removida manualmente. Loss streak zerado.');
    updateUI();
  }

  function toggleTestMode(){
    S.testMode = !S.testMode;
    log(`Modo Teste: ${S.testMode ? 'ON' : 'OFF'}`);
    updateUI();
  }

  // =============================
  // BIND
  // =============================
  el.btnStart.addEventListener('click', start);
  el.btnStop.addEventListener('click', stop);
  el.btnOnce.addEventListener('click', tick);
  el.btnReset.addEventListener('click', resetAll);
  el.btnUnlock.addEventListener('click', unlockSafety);
  $('btnCloseAll').addEventListener('click', closeAllOpenMarket);
  el.btnTestMode.addEventListener('click', toggleTestMode);

  el.profileSeg.addEventListener('click', (ev) => {
    const btn = ev.target?.closest?.('button[data-prof]');
    const prof = btn?.getAttribute('data-prof');
    if (prof) setProfile(prof);
  });

  // init
  setProfile(S.profile);

  // ‚úÖ inicia d√≥lar ao carregar
  updateUsdBrl();
  S.usdTimer = setInterval(updateUsdBrl, 10_000);

  log('App pronto. Clique em "Ligar Rob√¥" ou "Rodar 1x".');
  updateUI();

  // carrega lista completa (USDT spot)
  (async () => {
    try{
      log('Carregando tickers da Binance (exchangeInfo)...');
      S.symbolsUniverse = await fetchExchangeInfoUSDT();
      populateSymbolsSelect(S.symbolsUniverse);
      log(`Tickers carregados: ${S.symbolsUniverse.length} pares USDT spot.`);
    }catch(e){
      log(`‚ö†Ô∏è Falha ao carregar tickers: ${e?.message || String(e)} (usando lista padr√£o).`);
    }
  })();

  window.guardian = { tick, setProfile, getCfg: () => getCfg() };
})();
</script>

</body>
</html>
